# Алгоритмическая сложность в программировании

Представлен график функций О-большое для оценки алгоритмической сложности.

Я создал этот рисунок, подбирая цвета и линии, так чтобы картинка была наглядной и легкочитаемой. (Вы можете скачивать его и делиться).

## Краткая теория

Можно оценивать алгоритм "напрямую", экспериментально, замерами времени его работы на разных данных.
Можно оценивать алгоритм асимптотически.

Асимптотический анализ алгоритма вычисляет степень (порядок) роста функции. Для алгоритмов это порядок роста **времени** работы алгоритма относительно **увеличения размера** входных данных.

## Нотации

3 асимптотические нотации определяют "отношения порядка":
- Big-O, Большое О (O-нотация)
- Omega, Омега (Ω-нотация)
- Theta, Тета (Θ-нотация)

О-большое (Order of): оценка функции сверху (upper bound).

Если сложность алгоритма оценивается как `O(f(N))`, где N - объем входной информации, то это значит, что с увеличением параметра N время работы алгоритма будет иметь порядок возрастания не больше `f(N)`.

## Пример

Какую алгоритмическую сложность имеет ниже приведенный алгоритм, где c - некая константа, n - переменная величина?

```java
for (int i = 1; i <= n; i += c) {
⠀⠀for (int j = 1; j <= n; j += c) {
⠀⠀⠀⠀// внутри операции O(1)
⠀⠀}
}
```

**Ответ.** Посчитаем кол-во итераций: `N / c * N / c * O(1) = O(N^2)`
Данный алгоритм имеет квадратичную сложность.

То есть при увеличении параметра N, кол-во итераций алгоритма будет изменяться как `N^2`.

